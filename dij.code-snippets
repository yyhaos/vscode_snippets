{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"dij": {
        "prefix": "dij",
        "body": [
            "//Problem Web:",
            "#include<bits/stdc++.h>",
            "#include<ext/rope>",
            "using namespace std;",
            "#ifdef yyhao",
            "const std::string currentDateTime() {",
            "\ttime_t\t now = time(0);",
            "\tstruct tm  tstruct;",
            "\tchar\t   buf[80];",
            "\ttstruct = *localtime(&now);",
            "\t// Visit http://en.cppreference.com/w/cpp/chrono/c/strftime",
            "\t// for more information about date/time format",
            "\tstrftime(buf, sizeof(buf), \"%Y-%m-%d.%X\", &tstruct);",
            "",
            "\treturn buf;",
            "}",
            "#endif",
            "#define ll long long",
            "#define lowbit(x) (x&-x)",
            "#define rep(i,x,y) for(int i=x;i<=y;i++)",
            "#define crep(i,x,y) for(int i=x;i>=y;i--)",
            "#define gcd(x,y) __gcd(x,y)",
            "#define mem(x,y) memset(x,y,sizeof(x))",
            "//#define use_t 1",
            "const double PI=acos(-1.0);",
            "const double eps=1e-8;",
            "const ll INF = 100000000;",
            "const ll maxn=1000;",
            "const ll q=1e9+7;",
            "",
            "using namespace std;",
            "",
            "struct Edge {",
            "\tint to;",
            "\tint weight;",
            "",
            "\tEdge(int t, int w) : to(t), weight(w) {}",
            "",
            "\t// 重载 < 运算符，将权重较小的边放在优先级队列的顶部",
            "\tbool operator<(const Edge& other) const {",
            "\t\treturn weight > other.weight; // 因为 priority_queue 默认是最大堆，我们需要反向比较",
            "\t}",
            "};",
            "",
            "void dijkstra(int start, vector<vector<Edge>>& graph, vector<int>& dist, vector<int>& prev) {",
            "\tpriority_queue<Edge> pq; ",
            "\tdist[start] = 0;",
            "\tpq.push(Edge(start, 0));",
            "",
            "\twhile (!pq.empty()) {",
            "\t\tEdge current_edge = pq.top();",
            "\t\tint current = current_edge.to;",
            "\t\tint distance = current_edge.weight;",
            "\t\tpq.pop();",
            "",
            "\t\tif (dist[current] < distance) continue;",
            "",
            "\t\tfor (const auto& edge: graph[current]) {",
            "\t\t\tint next = edge.to;",
            "\t\t\tint next_distance = distance + edge.weight;",
            "",
            "\t\t\tif (next_distance < dist[next]) {",
            "\t\t\t\tdist[next] = next_distance;",
            "\t\t\t\tprev[next] = current;",
            "\t\t\t\tpq.push(Edge(next, next_distance));",
            "\t\t\t}",
            "\t\t}",
            "\t}",
            "}",
            "",
            "void print_path(int vertex, const vector<int>& prev) {",
            "\tstack<int> path;",
            "\twhile (vertex != -1) {",
            "\t\tpath.push(vertex);",
            "\t\tvertex = prev[vertex];",
            "\t}",
            "",
            "\twhile (!path.empty()) {",
            "\t\tcout << path.top();",
            "\t\tpath.pop();",
            "\t\tif (!path.empty()) {",
            "\t\t\tcout << \" -> \";",
            "\t\t}",
            "\t}",
            "",
            "\tcout << endl;",
            "}",
            "",
            "ll ksm(ll a,ll b)",
            "{",
            "\tll ans=1LL;",
            "\twhile(b>0)",
            "\t{",
            "\t\tif(b&1LL)",
            "\t\t\tans=ans*a%q;",
            "\t\ta=a*a%q;",
            "\t\tb/=2LL;",
            "\t}",
            "\treturn ans;",
            "}",
            "struct S {",
            "\tll a, b;",
            "\tbool operator<(const S& other) const {",
            "\t\tif(a == other.a) {",
            "\t\t\treturn b > other.b;// 注意这里使用 '>' 是为了实现最小堆，即 b 较小的在前",
            "\t\t}",
            "\t\treturn a > other.a;  // 注意这里使用 '>' 是为了实现最小堆，即 a 较小的在前",
            "\t}",
            "};",
            "priority_queue<S> pq;",
            "",
            "ll t,n,m,k;",
            "ll us[10]={6,2,5,5,4,5,6,3,7,6};",
            "const ll N = 100005;",
            "ll c[N];",
            "int main ()",
            "{",
            "#ifdef yyhao",
            "\tfreopen(\"in.txt\",\"r\",stdin);",
            "\t//freopen(\"out.txt\",\"w\",stdout);",
            "\tcout<<\"Time:\"<<currentDateTime()<<endl;",
            "#endif",
            "#define use_t",
            "#ifdef use_t",
            "int ii=1;",
            "cin>>t;",
            "for(ii=1;ii<=t;ii++)",
            "{ ",
            "#endif // use_t",
            "\tint V, E, start;",
            "\tcin >> V >> E >> start;",
            "",
            "\tvector<vector<Edge>> graph(V + 1);",
            "\tvector<int> dist(V + 1, INT_MAX);",
            "\tvector<int> prev(V + 1, -1);",
            "",
            "\tfor (int i = 0; i < E; ++i) {",
            "\t\tint from, to, weight;",
            "\t\tcin >> from >> to >> weight;",
            "\t\tgraph[from].push_back(Edge(to, weight));",
            "\t}",
            "",
            "\tdijkstra(start, graph, dist, prev);",
            "",
            "\tfor (int i = 1; i <= V; ++i) {",
            "\t\tcout << \"Shortest distance to vertex \" << i << \" is \" << dist[i] << endl;",
            "\t\tif (dist[i] != INT_MAX) {",
            "\t\t\tcout << \"Path: \";",
            "\t\t\tprint_path(i, prev);",
            "\t\t}",
            "\t}",
            "#ifdef use_t",
            "}",
            "#endif // use_t",
            "\treturn 0;",
            "}",
            ""
        ]
    }
}